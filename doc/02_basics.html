<!DOCTYPE html>
<html>
  <head>
    <title>Haskell in Haste - Basics</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      /* latin-ext */
      @font-face {
        font-family: 'Yanone Kaffeesatz';
        font-style: normal;
        font-weight: 400;
        src: local('Yanone Kaffeesatz Regular'), local('YanoneKaffeesatz-Regular'), url(fonts/YDAoLskQQ5MOAgvHUQCcLaa0P60JZGaCMFbL3N9v4H0.woff2) format('woff2');
        unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
      }
      /* latin */
      @font-face {
        font-family: 'Yanone Kaffeesatz';
        font-style: normal;
        font-weight: 400;
        src: local('Yanone Kaffeesatz Regular'), local('YanoneKaffeesatz-Regular'), url(../fonts/YDAoLskQQ5MOAgvHUQCcLWjF_m7mVnhXExjNED3rUtY.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }

      /* latin */
      @font-face {
        font-family: 'Droid Serif';
        font-style: normal;
        font-weight: 400;
        src: local('Droid Serif'), local('DroidSerif'), url(../fonts/0AKsP294HTD-nvJgucYTaIgp9Q8gbYrhqGlRav_IXfk.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
      /* latin */
      @font-face {
        font-family: 'Droid Serif';
        font-style: normal;
        font-weight: 700;
        src: local('Droid Serif Bold'), local('DroidSerif-Bold'), url(../fonts/QQt14e8dY39u-eYBZmppwf79_ZuUxCigM2DespTnFaw.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
      /* latin */
      @font-face {
        font-family: 'Droid Serif';
        font-style: italic;
        font-weight: 400;
        src: local('Droid Serif Italic'), local('DroidSerif-Italic'), url(../fonts/cj2hUnSRBhwmSPr9kS589weOulFbQKHxPa89BaxZzA0.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 700;
        src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url(../fonts/ceqTZGKHipo8pJj4molytv79_ZuUxCigM2DespTnFaw.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 400;
        src: local('Ubuntu Mono'), local('UbuntuMono-Regular'), url(../fonts/ViZhet7Ak-LRXZMXzuAfkYgp9Q8gbYrhqGlRav_IXfk.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }

      body {
        font-family: Futura, 'Yanone Kaffeesatz';
      }
      li {
        font-size: 30px;
        padding-top: 20px;
      }
      .remark-code {
        font-size: 30px;
      }
      h1, h2, h3 {
        font-weight: normal;
      }
      .inverse {
        background: #4795c6;
        color: white;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
      }
      .relative h1 {
        position: relative !important;
      }
      .question {
        background: #76b242;
        color: white;
      }
      .rule {
        background: #ee2a24;
        color: white;
      }
      .error {
        color: #ee2a24;
        font-size: 30px;
      }
      .image {
        padding: 0px;
        color: white;
        background-color: black;

        position: relative;
      }
      .image img {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        float: left;
      }
      .image h1, .image h2 {
        position: absolute;
        bottom: 0;
        text-align: center;
        left: 20px;
      }
      .image-white {
        color: black;
        background-color: white;
      }
      .image-last h1 {
        right: 0;
        bottom: 100px;
      }
      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono';
      }
      .remark-slide-content {
        padding: 10px 10px 10px 30px;
      }
      .hljs-default .hljs {
        background-color: transparent;
        padding: 0px !important;
      }
      .top h1 {
        top: 0px;
      }
      .toc {
         color: #777;
         margin-top: 135px;
      }
      .toc-selected {
         color: #000;
      }
      .code-small .remark-code {
        font-size: 20px;
      }
      .remark-container {
        height: 100%;
        width: 100%;
      }
      .remark-slide-number {
        display: none;
      }
      .red span {
        color: red;
      }
    </style>
  </head>
  <body>

    <textarea id="source">
name: image
layout: true
class: center, middle, image

---
name: image-white
layout: true
class: center, middle, image, image-white

---
name: image-last
layout: true
class: center, middle, image, image-last

---
name: code-small
layout: true
class: code-small

---
name: question
layout: true
class: center, middle, question

---
name: rule
layout: true
class: center, middle, rule

---
name: boom
layout: true
class: boom

---
name: inverse
layout: true
class: center, middle, inverse

---

class: center, middle
template: image
layout: false

# Basics











---
layout: false

## Hello World

```haskell
putStrLn "Hello world"
```

---

## Calling a function

```haskell
> add 1 2
3
```

---

## Calling a function

```haskell
> add 1 2
3
```

### Javascript

```js
add(1, 2);
```

---

## Calling a function

```haskell
> add 1 2
3

> add 1 (add 2 3)
6
```

---

## Calling a function

```haskell
> add 1 2
3

> add 1 (add 2 3)
6

> add (add 1 2) 3
6
```

---

## Calling a function

```haskell
> add 1 2
3

> add 1 (add 2 3)
6

> add (add 1 2) 3
6

> add "1" 2
```

---

## Calling a function

```haskell
> add 1 2
3

> add 1 (add 2 3)
6

> add (add 1 2) 3
6

> add "1" 2
<interactive>:8:1:
Couldn't match expected type ‘Int’
  with actual type ‘[Char]’
```

---

## Writing a function

```haskell
add     =
```

### Javascript

```js
function add() {

}
```

---

## Writing a function

```haskell
add a b =
```

### Javascript

```js
function add(a, b) {

}
```

---

## Writing a function

```haskell
add a b = a + b
```

### Javascript

```js
function add(a, b) {
  return a + b;
}
```

---

## GHCi functions

```haskell
>     add a b = a + b
```

---

## GHCi functions

```haskell
>     add a b = a + b
```

<pre class="error">
&lt; interactive&gt;:3:9: parse error on input ‘=’
</pre>

---

## GHCi functions

```haskell
> let add a b = a + b
```

---

## GHCi functions

```haskell
> let add a b = a + b
> add 1 2
3
```

---

## Type Inference

```haskell
add a b = a + b
```

```
> :t add
```

---

## Type Inference

```haskell
add a b = a + b
```

```
> :t add
add :: Int -> Int -> Int
```

---

## Reading a function type signature

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-title">add</span> :: <span style="color: blue;">Int</span> -&gt; <span style="color: green;">Int</span> -&gt; <span style="color: orange;">Int</span></div><div class="remark-code-line"><span class="hljs-title">add</span> <span style="color: blue">a</span> <span style="color: green">b</span> = <span style="color: orange">a + b</span></div>
</code></pre>

---

## Reading a function type signature

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-title">add</span> :: <span style="color: blue;">Int</span> -&gt; <span style="color: green;">Int</span> -&gt; <span style="color: orange;">Int</span></div><div class="remark-code-line"><span class="hljs-title">add</span> <span style="color: blue">a</span> <span style="color: green">b</span> = <span style="color: orange">a + b</span></div>
</code></pre>

### Java

<pre><code class="java hljs scala remark-code"><div class="remark-code-line">public <span style="color: orange">int</span> add(<span style="color: blue">int a</span>, <span style="color: green">int b</span>) {</div><div class="remark-code-line">  <span class="hljs-keyword">return</span> a + b;</div><div class="remark-code-line">}</div>
</code></pre>











---

template: inverse

## Let Binding

---

##  Duplicate code

```haskell
exp = add (add 1 2) (add 1 2)
```

---

## Let

```haskell
exp = add (add 1 2) (add 1 2)

exp =
  let .... = ...
  in ...
```

---

## Let

```haskell
exp = add (add 1 2) (add 1 2)

exp =
  let three = add 1 2
  in add three three
```

---

## Let

```haskell
exp = add (add 1 2) (add 1 2)

exp =
  let three = add 1 2
  in add three three
```

### Javascript

```js
function exp() {
  var three = add(1, 2);
  return add(three, three);
}
```

---

## Let arguments

```haskell
exp =
  let add3 x = add 3 x
  in add (add3 4) (add3 5)
```

---

## Let arguments

```haskell
exp =
  let add3 x = add 3 x
  in add (add3 4) (add3 5)
```

### Javascript

```js
function exp() {
  var add3 = function(x) {
    return add(3, x);
  }
  return add(add3(4), add3(5));
}
```

---

## Let arguments + types

```haskell
exp =
  let add3 :: ???
      add3 x = add 3 x
  in add (add3 4) (add3 5)
```

---

## Let arguments + types

```haskell
exp =
  let add3 :: Int -> Int
      add3 x = add 3 x
  in add (add3 4) (add3 5)
```

---

## Let multiple

```haskell
exp =
  let three = add 1 2
      six = add three three
  in add three six
```

---

## Let multiple

```haskell
exp =
  let three = add 1 2
      six = add three three
      nine = add six three
      ...
  in add three six
```


















---

template: inverse

## Data types

---

## Data types

```haskell
data Fruit = Apple | Banana | Tomato
```

---

## Data types

```haskell
data Fruit = Apple | Banana | Tomato
```

- Similar to an "enum"
- Can _only_ be these values
  - Can't be `Orange`
  - Can't be "extended" by someone else

---

## Data types

```haskell
data Fruit = Apple | Banana | Tomato
```

- _Must_ start with Upper Case

---

## Data types - Uppercase

```haskell
data fruit = Apple | Banana | Tomato
```

---

## Data types - Uppercase

```haskell
data fruit = Apple | Banana | Tomato
```

<pre class="error">
Malformed head of type or class declaration:
  fruit
</pre>

---

## Data types - Uppercase

```haskell
data Fruit = apple | banana | tomato
```

---

## Data types - Uppercase

```haskell
data Fruit = apple | banana | tomato
```

<pre class="error">
Not a data constructor: &quot;apple&quot;
<pre>

---

## Data types - Uppercase

```haskell
data Fruit = Apple | Banana | Tomato
```

---

## Pattern Matching


```haskell
data Fruit = Apple | Banana | Tomato

fruitRender :: Fruit -> String
fruitRender fruit =
  ...
```

---

## Pattern Matching


```haskell
data Fruit = Apple | Banana | Tomato

fruitRender :: Fruit -> String
fruitRender fruit = case fruit of
  Apple -> ...
  Banana -> ...
  Tomato -> ...
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

fruitRender :: Fruit -> String
fruitRender fruit = case fruit of
  Apple -> "apple"
  Banana -> "banana"
  Tomato -> "tomato"
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

fruitRender :: Fruit -> String
fruitRender fruit = case fruit of
  Apple -> "apple"
  Banana -> "banana"
  Tomato -> "tomato"
```

```haskell
fruitRender :: Fruit -> String
fruitRender Apple = "apple"
fruitRender Banana = "banana"
fruitRender Tomato = "tomato"
```


---

## Exhaustive Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

fruitRender :: Fruit -> String
fruitRender fruit = case fruit of
  Banana -> "banana"
  Tomato -> "tomato"
```

---

## Exhaustive Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

fruitRender :: Fruit -> String
fruitRender fruit = case fruit of
  Banana -> "banana"
  Tomato -> "tomato"
```

<pre class="error">
Fruit.hs:5:1: Warning:
  Pattern match(es) are non-exhaustive
  In an equation for ‘fruitRender’:
    Patterns not matched: Apple
</pre>


---

## Exhaustive Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

fruitRender :: Fruit -> String
fruitRender fruit = case fruit of
  Banana -> "banana"
  Tomato -> "tomato"
```

```haskell
> fruitRender Apple
```
<pre class="error">
"*** Exception: src/Example.hs:(9,21)-(11,20):
  Non-exhaustive patterns in case
</pre>

---

## Deriving

```haskell
data Fruit = Apple | Banana | Tomato

> Apple
```

---

## Deriving

```haskell
data Fruit = Apple | Banana | Tomato

> Apple
```

<pre class="error">
No instance for (Show Fruit) arising from a 
  use of ‘print’
</pre>

---

## Deriving

```haskell
data Fruit = Apple | Banana | Tomato
  deriving Show
```

---

## Deriving

```haskell
data Fruit = Apple | Banana | Tomato
  deriving Show

> Apple
Apple
```

---

## Deriving

```haskell
data Fruit = Apple | Banana | Tomato
  deriving Show

> Apple
Apple
```

- Special Haskell
- Think of it like `toString()` in many languages
- Except it's not added to data types by default






---

template: question

## Boolean

---

## Boolean

```haskell
data Bool = True | False
```

---

## Boolean

```haskell
data Bool = True | False
```

- Just a data type

---

## Boolean

```haskell
data Bool = True | False
```

<br/>

```haskell
not :: Bool -> Bool
not b = ...
```

---

## Boolean

```haskell
data Bool = True | False
```

<br/>

```haskell
not :: Bool -> Bool
not True = False
not False = True
```

---

## Boolean - if/then/else

```haskell


  if .... then ..... else .....
```

- "Special" syntax

---

## Boolean - if/then/else

```haskell
not :: Bool -> Bool
not bool =
  if bool then False else True
```

---

## Boolean - if/then/else

```haskell
not :: Bool -> Bool
not bool =
  if bool
    then False
    else True
```









---

template: question

## Data Types ++

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

fruitRender :: Fruit -> String
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

parseFruit :: String -> Fruit
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

parseFruit :: String -> Fruit
parseFruit string = case string of
  ...
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

parseFruit :: String -> Fruit
parseFruit string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

parseFruit :: String -> Fruit
parseFruit string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
  _ -> ???
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

parseFruit :: String -> Fruit
parseFruit string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
  _ -> null
```

---

template: question
## Haskell has no `null`

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

parseFruit :: String -> Fruit
parseFruit string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
  _ -> ???
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit       | NothingFruit
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit
```

---

## Data Types ++

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Fruit</span> = <span class="hljs-type">Apple</span> | <span class="hljs-type">Banana</span> | <span class="hljs-type">Tomato</span></span></div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span style="color: green;">MaybeFruit</span> = <span class="hljs-type">JustFruit</span> <span class="hljs-type">Fruit</span> | <span class="hljs-type">NothingFruit</span></span></div>
</code></pre>

- `MaybeFruit` is the <span style="color: green;">"type"</span>

---

## Data Types ++

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Fruit</span> = <span class="hljs-type">Apple</span> | <span class="hljs-type">Banana</span> | <span class="hljs-type">Tomato</span></span></div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">MaybeFruit</span> = <span style="color: blue;">JustFruit</span> <span class="hljs-type">Fruit</span> | <span style="color: blue;">NothingFruit</span></span></div>
</code></pre>

- `MaybeFruit` is the "type"
- `JustFruit`/`NothingFruit` are the <span style="color: blue;">"constructors"</span>

---

## Data Types ++

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span style="color: orange;">Fruit</span> = <span class="hljs-type">Apple</span> | <span class="hljs-type">Banana</span> | <span class="hljs-type">Tomato</span></span></div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">MaybeFruit</span> = <span>JustFruit</span> <span style="color: orange;">Fruit</span> | <span>NothingFruit</span></span></div>
</code></pre>

- `MaybeFruit` is the "type"
- `JustFruit`/`NothingFruit` are the "constructors"
- Data constructors can contain <span style="color: orange;">other types</span>

---

## _Very_ loose comparison

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Fruit</span> = <span class="hljs-type">Apple</span> | <span class="hljs-type">Banana</span> | <span class="hljs-type">Tomato</span></span></div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span style="color: green;">MaybeFruit</span> = <span style="color: blue;">JustFruit</span> <span style="color: orange;">Fruit</span> | <span style="color: blue;">NothingFruit</span></span></div>
</code></pre>

### Java

<pre><code class="java hljs scala remark-code"><div><span class="hljs-keyword">interface</span> <span style="color: green;">MaybeFruit</span> { }</div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustFruit</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">MaybeFruit</span> {</span></div><div class="remark-code-line">  public <span style="color: blue;">JustFruit</span>(<span style="color: orange;">Fruit</span> f) { .. }</div><div class="remark-code-line">}</div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NothingFruit</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">MaybeFruit</span> {</span></div><div class="remark-code-line">  public <span class="hljs-type"><span style="color: blue;">NothingFruit</span></span>() { .. }</div><div class="remark-code-line">}</div>
</code></pre>

---

## Constructors are just functions

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit
```

```haskell
> :t JustFruit
Fruit -> MaybeFruit

> :t NothingFruit
MaybeFruit
```

---

## Constructors are just functions

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit
```

```haskell
> :t Yum Apple
Eat

> :t Yuck Tomato "Not a fruit"
Eat
```

---

## Constructors are just functions

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit
```

```haskell
> let r1 = JustFruit Apple

> let r2 = NothingFruit

> :t r1
r1 :: MaybeFruit
```

---

## Constructors are just functions

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit
```

```haskell
> let r1 = JustFruit Apple

> let r2 = NothingFruit
```

### Java

```java
MaybeFruit r1 = new JustFruit(Apple)

MaybeFruit r2 = new NothingFruit()
```

---

## Example

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

parseFruit :: String -> Fruit
parseFruit string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
  _ -> ???
```

---

## Example

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

parseFruit :: String -> MaybeFruit
parseFruit string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
  _ -> ???
```

---

## Example

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

parseFruit :: String -> MaybeFruit
parseFruit string = case string of
  "apple" -> JustFruit Apple
  "banana" -> JustFruit Banana
  "tomato" -> JustFruit Tomato
  _ -> NothingFruit
```

---

## Example

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

parseFruit :: String -> MaybeFruit
parseFruit string = case string of
  "apple" -> JustFruit Apple
  "banana" -> JustFruit Banana
  "tomato" -> JustFruit Tomato
  _ -> NothingFruit
```

```haskell
> parseFruit "apple"
JustFruit Apple
> parseFruit "carrot"
NothingFruit
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
maybeFruit mf = case mf of
  ...
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
maybeFruit mf = case mf of
  JustFruit fruit -> ...
  NothingFruit -> ...
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
maybeFruit mf = case mf of
  JustFruit fruit -> fruit
  NothingFruit -> ...
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
maybeFruit mf = case mf of
  JustFruit fruit -> fruit
  NothingFruit -> Apple
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit -> Fruit
maybeFruit mf other = case mf of
  JustFruit fruit -> fruit
  NothingFruit -> other
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit -> Fruit
```

<br/>

```haskell
> maybeFruit (parseFruit "apple") Banana
Apple
> maybeFruit (parseFruit "carrot") Banana
Banana
```





















---

template: question
## Immutable

---

## Immutable data

```haskell
data Count = CountValue Int deriving Show
```

---

## Immutable data

```haskell
data Count = CountValue Int deriving Show

zero :: Count
zero = CountValue 0
```

---

## Immutable data

```haskell
data Count = CountValue Int deriving Show

zero :: Count
zero = CountValue 0

increment :: Count -> Count
increment c = ...
```

---

## Immutable data

```haskell
data Count = CountValue Int deriving Show

zero :: Count
zero = CountValue 0

increment :: Count -> Count
increment (CountValue c) = CountValue (c + 1)
```

---

## Immutable data

```haskell
data Count = CountValue Int deriving Show

zero :: Count
zero = CountValue 0

increment :: Count -> Count
increment (CountValue c) = CountValue (c + 1)

> increment zero
CountValue 1
```

---

## Immutable data

```haskell
data Count = CountValue Int deriving Show

zero :: Count
zero = CountValue 0

increment :: Count -> Count
increment (CountValue c) = CountValue (c + 1)

> increment zero
CountValue 1
> zero
CountValue 0
```













---

template: inverse

# Lists

---

## Lists

```haskell

list = [1, 2, 3, 4]
```

---

## Lists

```haskell
list :: [Int]
list = [1, 2, 3, 4]
```

---

## Char

```haskell

a   =  'a'
```

---

## Char

```haskell

a   =  'a'

> :t a
```

---

## Char

```haskell

a   =  'a'

> :t a
Char
```

---

## Char

```haskell
a   :: Char
a   =  'a'
```

---

## List of Chars

```haskell
a   :: [Char]
a   = ['a']
```

---

## List of Chars

```haskell
abc :: [Char]
abc = ['a', 'b', 'c']
```

---

## Strings are [Char]

```haskell
abc :: String
abc = ['a', 'b', 'c']
```

---

## Strings are [Char]

```haskell
abc :: String
abc = "abc"
```

---

## Empty List

```haskell

list = []
```

---

## Lists

```haskell
list :: [Int]
list = []
```

---

## Lists

```haskell
list :: [Int]
list = [1]
```

---

## Lists

```haskell
list :: [Int]
list = 1 : []
```

---

## Lists

```haskell
list :: [Int]
list = 1 : []

> list
[1]
```

---

## Lists

```haskell
list :: [Int]
list = 1 : []
```

- '`:`' is pronouced "cons"
- You might hear the term "cons list"

---

## Lists

```haskell
list :: [Int]
list = 1 : [2]
```

---

## Lists

```haskell
list :: [Int]
list = 1 : [2]

> list
[1, 2]
```

---

## Lists

```haskell
list :: [Int]
list = 1 : 2 : []

> list
[1, 2]
```

---

## Lists

```haskell
list :: [Int]
list = [1, 2] : [3, 4]
```

---

## Lists

```haskell
list :: [Int]
list = [1, 2] : [3, 4]
```

<pre class="error" style="font-size: 22px;">
Couldn't match expected type ’Int’ with actual type ‘[Int]’
</pre>

---

## Pattern matching

```haskell
drop1 :: [Int] -> [Int]
drop1 l = ...
```

---

## Pattern matching

```haskell
drop1 :: [Int] -> [Int]
drop1 l = case l of
  [] -> []
  ...
```

---

## Pattern matching

```haskell
drop1 :: [Int] -> [Int]
drop1 l = case l of
  [] -> []
  a : b -> b
```

---

## Pattern matching

```haskell
drop1 :: [Int] -> [Int]
drop1 l = case l of
  [] -> []
  a : b -> b
``` 

```haskell
> drop1 []
[]
```

---

## Pattern matching

```haskell
drop1 :: [Int] -> [Int]
drop1 l = case l of
  [] -> []
  a : b -> b
```

```haskell
> drop1 [1]
[]
```

---

## Pattern matching

```haskell
drop1 :: [Int] -> [Int]
drop1 l = case l of
  [] -> []
  a : b -> b
```

```haskell
> drop1 (1 : [])
[]
```

---

## Pattern matching

```haskell
drop1 :: [Int] -> [Int]
drop1 l = case l of
  [] -> []
  a : b -> b
```

```haskell
> drop1 (1 : [2])
[2]
```

---

## Pattern matching

```haskell
drop1 :: [Int] -> [Int]
drop1 l = case l of
  [] -> []
  a : b -> b
```

```haskell
> drop1 (1 : [2, 3])
[2,3]
```

---

## Pattern matching

```haskell
drop1 :: [Int] -> [Int]
drop1 l = case l of
  [] -> []
  a : b -> b
```

```haskell
> drop1 [1,  2,  3]
[2,3]
```

---

## Pattern matching

```haskell
startsWith :: Int -> [Int] -> Bool
startsWith i l = case l of
  [] -> ...
  h : v -> ...
```

---

## Pattern matching

```haskell
startsWith :: Int -> [Int] -> Bool
startsWith i l = case l of
  [] -> False
  h : v -> ...
```

---

## Pattern matching

```haskell
startsWith :: Int -> [Int] -> Bool
startsWith i l = case l of
  [] -> False
  h : v -> i == h
```

---

## Pattern matching

```haskell
startsWith :: Int -> [Int] -> Bool
startsWith i l = case l of
  [] -> False
  h : v -> i == h
```

```haskell
> startsWith 1 []
False
```

---

## Pattern matching

```haskell
startsWith :: Int -> [Int] -> Bool
startsWith i l = case l of
  [] -> False
  h : v -> i == h
```

```haskell
> startsWith 1 [1]
True
```

---

## Pattern matching

```haskell
startsWith :: Int -> [Int] -> Bool
startsWith i l = case l of
  [] -> False
  h : v -> i == h
```

```haskell
> startsWith 1 (1: [])
True
```

---

template: question
## What about loops yo?

---

## Recursion

```haskell
contains :: Int -> [Int] -> Bool
```

---

## Recursion

```haskell
contains :: Int -> [Int] -> Bool
```


### Javascript

```js
function contains(v, list) {
  var found = false;
  for (var i = 0; !found &amp;&amp; i &lt; list.length; i++) {
    found = list[i] === v
  }
  return found;
}
```

---

## Recursion

```haskell
contains :: Int -> [Int] -> Bool
contains v l = case l of
  [] -> ...
  h : t -> ...
```


---

## Recursion

```haskell
contains :: Int -> [Int] -> Bool
contains v l = case l of
  [] -> False
  h : t -> ...
```

---

## Recursion

```haskell
contains :: Int -> [Int] -> Bool
contains v l = case l of
  [] -> False
  h : t ->
    if v == h then True else ...
```

---

## Recursion

```haskell
contains :: Int -> [Int] -> Bool
contains v l = case l of
  [] -> False
  h : t ->
    if v == h then True else contains v t
```

---

## Recursion

```haskell
contains :: Int -> [Int] -> Bool
contains v l = case l of
  [] -> False
  h : t ->
    if v == h then True else contains v t
```

```haskell
> contains 1 []
False
```

---

## Recursion

```haskell
contains :: Int -> [Int] -> Bool
contains v l = case l of
  [] -> False
  h : t ->
    if v == h then True else contains v t
```

```haskell
> contains 1 [2]
False
```

---

## Recursion

```haskell
contains :: Int -> [Int] -> Bool
contains v l = case l of
  [] -> False
  h : t ->
    if v == h then True else contains v t
```

```haskell
> contains 1 [2, 1]
True
```

---

## Recursion

```haskell
contains :: Int -> [Int] -> Bool
contains v l = case l of
  [] -> False
  h : t ->
    if v == h then True else contains v t
```

```haskell
> contains 1 (2 : 1 : [])
True
```












---

template: inverse
## Parametricity

---

## Remember this?

```haskell
drop1 :: [Int] -> [Int]
drop1 l = case l of
  [] -> []
  a : b -> b
```

---

## Is this the same?

```haskell
drop1 :: [Char] -> [Char]
drop1 l = case l of
  [] -> []
  a : b -> b
```

---

## No type

```haskell

drop1 l = case l of
  [] -> []
  a : b -> b
```

---

## No type

```haskell

drop1 l = case l of
  [] -> []
  a : b -> b
```

```
> drop1 [1, 2, 3]
[2,3]
```

---

## No type

```haskell

drop1 l = case l of
  [] -> []
  a : b -> b
```

```
> drop1 [1, 2, 3]
[2,3]
```

```
> drop1 "abc"
"bc"
```

---

## What does haskell think?

```haskell

drop1 l = case l of
  [] -> []
  a : b -> b
```

```
> :t drop1
```

---

## What does haskell think?

```haskell

drop1 l = case l of
  [] -> []
  a : b -> b
```

```
> :t drop1
drop1 :: [t] -> [t]
```

---

## Parametric function

```haskell
drop1 :: [t] -> [t]
drop1 l = case l of
  [] -> []
  a : b -> b
```

---

## Parametric function

```haskell
drop1 :: [t] -> [t]
drop1 l = ...


```

### Java

```javascript
public &lt;T&gt; List&lt;T&gt; drop1(List&lt;T&gt; l) {
  ...
}
```

---

## Parametric function

```haskell
drop1 :: [t] -> [t]
drop1 l = ...
```

- Lowercase means type variable
  - Rember that uppercase is a "type"
- Don't need to "introduce" it











---

template: question
## Parametric Data

---

## Rememeber this?

```haskell
data MaybeFruit = JustFruit Fruit | NothingFruit

parseFruit :: String -> MaybeFruit
```

---

## Copy and paste

```haskell
data MaybeVege = JustVege Vege | NothingVege

parseVege :: String -> MaybeVege
```

---

## Copy and paste

```haskell
data Maybe??? = Just??? ??? | Nothing???

parse??? :: String -> Maybe???
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing
```

```haskell
> :t Just Apple
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing
```

```haskell
> :t Just Apple
Maybe Fruit
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing
```

```haskell
> :t Just "hello"
Maybe String
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing

parseFruit :: String -> Maybe Fruit
```

---

## MaybeFruit

```haskell
data MaybeFruit = JustFruit Fruit | NothingFruit

parseFruit :: String -> MaybeFruit
parseFruit string = case string of
  "apple" -> JustFruit Apple
  "banana" -> JustFruit Banana
  "tomato" -> JustFruit Tomato
  _ -> NothingFruit
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing

parseFruit :: String -> Maybe Fruit
parseFruit string = case string of
  "apple" -> Just Apple
  "banana" -> Just Banana
  "tomato" -> Just Tomato
  _ -> Nothing
```












    </textarea>
    <link rel="stylesheet" href="../js/styles/idea.css">
    <script src="../js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
