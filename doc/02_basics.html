<!DOCTYPE html>
<html>
  <head>
    <title>Haskell in Haste - Part 1</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="../js/styles.css" />
  </head>
  <body>

    <textarea id="source">
name: image
layout: true
class: center, middle, image

---
name: title
layout: true
class: center, middle, image, image-white, title

---
name: image-white
layout: true
class: center, middle, image, image-white

---
name: image-last
layout: true
class: center, middle, image, image-last

---
name: code-small
layout: true
class: code-small

---
name: question
layout: true
class: center, middle, question

---
name: rule
layout: true
class: center, middle, rule

---
name: boom
layout: true
class: boom

---
name: inverse
layout: true
class: center, middle, inverse

---

class: center, middle
template: title
layout: false

# Part 1











---
layout: false

## Hello World

```haskell
putStrLn "Hello world"
```

---

template: inverse

## Functions

---

## Calling a function

```haskell
> add 1 2
3
```

---

## Calling a function

```haskell
> add 1 2
3
```

### Javascript

```js
add(1, 2);
```

---

## Calling a function

```haskell
> add 1 2
3

> add 1 (add 2 3)
6
```

---

## Calling a function

```haskell
> add 1 2
3

> add 1 (add 2 3)
6

> add (add 1 2) 3
6
```

---

## Writing a function

```haskell
add     =
```

### Javascript

```js
function add() {

}
```

---

## Writing a function

```haskell
add a b =
```

### Javascript

```js
function add(a, b) {

}
```

---

## Writing a function

```haskell
add a b = a + b
```

### Javascript

```js
function add(a, b) {
  return a + b;
}
```

---

## GHCi functions

```haskell
>     minus a b = a - b
```

---

## GHCi functions

```haskell
>     minus a b = a + b
```

<pre class="error">
&lt; interactive&gt;:3:9: parse error on input ‘=’
</pre>

---

## GHCi functions

```haskell
> let minus a b = a + b
```

---

## GHCi functions

```haskell
> let minus a b = a + b
```

```
> minus 3 1
2
```

---

## Type Inference

```haskell
add a b = a + b
```

```
> :t add
```

---

## Type Inference

```haskell
add a b = a + b
```

```
> :t add
add :: Int -> Int -> Int
```

---

## Reading a function type signature

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-title">add</span> :: <span style="color: blue;">Int</span> -&gt; <span style="color: green;">Int</span> -&gt; <span style="color: orange;">Int</span></div><div class="remark-code-line"><span class="hljs-title">add</span> <span style="color: blue">a</span> <span style="color: green">b</span> = <span style="color: orange">a + b</span></div>
</code></pre>

---

## Reading a function type signature

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-title">add</span> :: <span style="color: blue;">Int</span> -&gt; <span style="color: green;">Int</span> -&gt; <span style="color: orange;">Int</span></div><div class="remark-code-line"><span class="hljs-title">add</span> <span style="color: blue">a</span> <span style="color: green">b</span> = <span style="color: orange">a + b</span></div>
</code></pre>

### Java

<pre><code class="java hljs scala remark-code"><div class="remark-code-line">public <span style="color: orange">int</span> add(<span style="color: blue">int a</span>, <span style="color: green">int b</span>) {</div><div class="remark-code-line">  <span class="hljs-keyword">return</span> a + b;</div><div class="remark-code-line">}</div>
</code></pre>












---

template: inverse

## Data

---

## Data types

```haskell
data Fruit = Apple | Banana | Tomato
```

---

## Data types

```haskell
data Fruit = Apple | Banana | Tomato
```

- Similar to an "enum"
- Can _only_ be these values
  - Can't be `Orange`
  - Can't be "extended" by someone else

---

## Data types

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type"><span style="color: green;">Fruit</span></span> = <span class="hljs-type">Apple</span> | <span class="hljs-type">Banana</span> | <span class="hljs-type">Tomato</span></span></div>
</code></pre>

- `Fruit` is the <span style="color: green;">"type"</span>

---

## Data types

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Fruit</span> = <span style="color: blue;">Apple</span> | <span style="color: blue;">Banana</span> | <span style="color: blue;">Tomato</span></span></div>
</code></pre>

- `Fruit` is the "type"
- `Apple`/`Banana`/`Tomato` are the <span style="color: blue;">"data constructors"</span>

---

## Data types

```haskell
data Fruit = Apple | Banana | Tomato
```

- _Must_ start with Upper Case

---

## Data types - Uppercase

```haskell
data fruit = Apple | Banana | Tomato
```

---

## Data types - Uppercase

```haskell
data fruit = Apple | Banana | Tomato
```

<pre class="error">
Malformed head of type or class declaration:
  fruit
</pre>

---

## Data types - Uppercase

```haskell
data Fruit = apple | banana | tomato
```

---

## Data types - Uppercase

```haskell
data Fruit = apple | banana | tomato
```

<pre class="error">
Not a data constructor: &quot;apple&quot;
<pre>

---

## Data types - Uppercase

```haskell
data Fruit = Apple | Banana | Tomato
```

---

## Pattern Matching


```haskell
data Fruit = Apple | Banana | Tomato

fruitToString :: Fruit -> String
fruitToString fruit =
  ???
```

---

## Pattern Matching


```haskell
data Fruit = Apple | Banana | Tomato

fruitToString :: Fruit -> String
fruitToString fruit =
  undefined
```

---

## Pattern Matching


```haskell
data Fruit = Apple | Banana | Tomato

fruitToString :: Fruit -> String
fruitToString fruit = case fruit of
  Apple -> undefined
  Banana -> undefined
  Tomato -> undefined
```

---

## Pattern Matching


```haskell
data Fruit = Apple | Banana | Tomato

fruitToString :: Fruit -> String
fruitToString fruit = case fruit of
  Apple -> "apple"
  Banana -> undefined
  Tomato -> undefined
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

fruitToString :: Fruit -> String
fruitToString fruit = case fruit of
  Apple -> "apple"
  Banana -> "banana"
  Tomato -> "tomato"
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

fruitToString :: Fruit -> String
fruitToString fruit = case fruit of
  Apple -> "apple"
  Banana -> "banana"
  Tomato -> "tomato"
```

```haskell
fruitToString :: Fruit -> String
fruitToString Apple = "apple"
fruitToString Banana = "banana"
fruitToString Tomato = "tomato"
```

---

template: question

## Magic

---

## Deriving

```haskell
data Fruit = Apple | Banana | Tomato

> Apple
```

---

## Deriving

```haskell
data Fruit = Apple | Banana | Tomato

> Apple
```

<pre class="error">
No instance for (Show Fruit) arising from a 
  use of ‘print’
</pre>

---

## Deriving

```haskell
data Fruit = Apple | Banana | Tomato
  deriving (Show)
```

---

## Deriving

```haskell
data Fruit = Apple | Banana | Tomato
  deriving (Show)

> Apple
Apple
```

---

## Deriving

```haskell
data Fruit = Apple | Banana | Tomato
  deriving (Show)

> Apple
Apple
```

- Special Haskell
- Think of it like `toString()` in many languages
- Except it's not added to data types by default






---

template: question

## Boolean

---

## Boolean

```haskell
data Bool = True | False
```

---

## Boolean

```haskell
data Bool = True | False
```

- Just a data type

---

## Boolean

```haskell
data Bool = True | False
```

<br/>

```haskell
not :: Bool -> Bool
not b = undefined
```

---

## Boolean

```haskell
data Bool = True | False
```

<br/>

```haskell
not :: Bool -> Bool
not True = False
not False = True
```

---

## Boolean - if/then/else

```haskell


  if .... then ..... else .....
```

- "Special" syntax

---

## Boolean - if/then/else

```haskell
not :: Bool -> Bool
not bool =
  if bool then False else True
```









---

template: question

## Data Types ++

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

fruitToString :: Fruit -> String
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

fruitFromString :: String -> Fruit
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

fruitFromString :: String -> Fruit
fruitFromString string = case string of
  ...
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

fruitFromString :: String -> Fruit
fruitFromString string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

fruitFromString :: String -> Fruit
fruitFromString string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
  _ -> undefined
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

fruitFromString :: String -> Fruit
fruitFromString string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
  _ -> null
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

fruitFromString :: String -> Fruit
fruitFromString string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
  _ -> null
```

### Haskell has _no_ `null`

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit       | NothingFruit
```

---

## Data Types ++

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit
```

---

## Data Types ++

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Fruit</span> = <span class="hljs-type">Apple</span> | <span class="hljs-type">Banana</span> | <span class="hljs-type">Tomato</span></span></div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span style="color: green;">MaybeFruit</span> = <span class="hljs-type">JustFruit</span> <span class="hljs-type">Fruit</span> | <span class="hljs-type">NothingFruit</span></span></div>
</code></pre>

- `MaybeFruit` is the <span style="color: green;">"type"</span>

---

## Data Types ++

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Fruit</span> = <span class="hljs-type">Apple</span> | <span class="hljs-type">Banana</span> | <span class="hljs-type">Tomato</span></span></div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">MaybeFruit</span> = <span style="color: blue;">JustFruit</span> <span class="hljs-type">Fruit</span> | <span style="color: blue;">NothingFruit</span></span></div>
</code></pre>

- `MaybeFruit` is the "type"
- `JustFruit`/`NothingFruit` are the <span style="color: blue;">"data constructors"</span>

---

## Data Types ++

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span style="color: orange;">Fruit</span> = <span class="hljs-type">Apple</span> | <span class="hljs-type">Banana</span> | <span class="hljs-type">Tomato</span></span></div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">MaybeFruit</span> = <span>JustFruit</span> <span style="color: orange;">Fruit</span> | <span>NothingFruit</span></span></div>
</code></pre>

- `MaybeFruit` is the "type"
- `JustFruit`/`NothingFruit` are the "data constructors"
- Data constructors can contain <span style="color: orange;">other types</span>

---

## _Very_ loose comparison

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Fruit</span> = <span class="hljs-type">Apple</span> | <span class="hljs-type">Banana</span> | <span class="hljs-type">Tomato</span></span></div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span style="color: green;">MaybeFruit</span> = <span style="color: blue;">JustFruit</span> <span style="color: orange;">Fruit</span> | <span style="color: blue;">NothingFruit</span></span></div>
</code></pre>

### Java

<pre><code class="java hljs scala remark-code"><div><span class="hljs-keyword">interface</span> <span style="color: green;">MaybeFruit</span> { }</div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustFruit</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">MaybeFruit</span> {</span></div><div class="remark-code-line">  public <span style="color: blue;">JustFruit</span>(<span style="color: orange;">Fruit</span> f) { .. }</div><div class="remark-code-line">}</div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NothingFruit</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">MaybeFruit</span> {</span></div><div class="remark-code-line">  public <span class="hljs-type"><span style="color: blue;">NothingFruit</span></span>() { .. }</div><div class="remark-code-line">}</div>
</code></pre>

---

## Constructors are just functions

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit
```

```haskell
> let r1 = JustFruit Apple

> let r2 = NothingFruit
```

---

## Constructors are just functions

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit
```

```haskell
> let r1 = JustFruit Apple

> let r2 = NothingFruit
```

### Java

```java
MaybeFruit r1 = new JustFruit(new Apple())

MaybeFruit r2 = new NothingFruit()
```

---

## Example

```haskell
data Fruit = Apple | Banana | Tomato



fruitFromString :: String -> Fruit
fruitFromString string = case string of
  "apple" -> Apple
  "banana" -> Banana
  "tomato" -> Tomato
  _ -> ???
```

---

## Example

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

fruitFromString :: String -> MaybeFruit
fruitFromString string = case string of
  "apple" -> ??? Apple
  "banana" -> ??? Banana
  "tomato" -> ??? Tomato
  _ -> ???
```

---

## Example

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

fruitFromString :: String -> MaybeFruit
fruitFromString string = case string of
  "apple" -> JustFruit Apple
  "banana" -> JustFruit Banana
  "tomato" -> JustFruit Tomato
  _ -> NothingFruit
```

---

## Example

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

fruitFromString :: String -> MaybeFruit
fruitFromString string = case string of
  "apple" -> JustFruit Apple
  "banana" -> JustFruit Banana
  "tomato" -> JustFruit Tomato
  _ -> NothingFruit
```

```haskell
> fruitFromString "apple"
JustFruit Apple
> fruitFromString "carrot"
NothingFruit
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
maybeFruit mf = case mf of
  ...
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
maybeFruit mf = case mf of
  JustFruit fruit -> undefined
  NothingFruit -> undefined
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
maybeFruit mf = case mf of
  JustFruit fruit -> fruit
  NothingFruit -> undefined
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
maybeFruit mf = case mf of
  JustFruit fruit -> fruit
  NothingFruit -> Apple
```

---

## Pattern Matching

```haskell
data Fruit = Apple | Banana | Tomato

data MaybeFruit = JustFruit Fruit | NothingFruit

maybeFruit :: MaybeFruit -> Fruit
```

<br/>

```haskell
> maybeFruit (fruitFromString "banana")
Banana
> maybeFruit (fruitFromString "carrot")
Apple
```

---

template: inverse

## Summary

---

## Summary

- `add 1 2`
- `add a b = a + b`
- `add :: Int -> Int -> Int`
- `data MaybeFruit = MaybeFruit Fruit | NothingFruit`
- <code>case fruit of </br>&nbsp;&nbsp;MaybeFruit fruit -> fruit</br>&nbsp;&nbsp;NothingFruit -> Apple</code>

---

template: inverse

## Next up: [Bots](04_bots.html)










    </textarea>
    <link rel="stylesheet" href="../js/styles/idea.css">
    <script src="../js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
