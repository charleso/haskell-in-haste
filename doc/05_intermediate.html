<!DOCTYPE html>
<html>
  <head>
    <title>Haskell in Haste - Intermediate</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      /* latin-ext */
      @font-face {
        font-family: 'Yanone Kaffeesatz';
        font-style: normal;
        font-weight: 400;
        src: local('Yanone Kaffeesatz Regular'), local('YanoneKaffeesatz-Regular'), url(fonts/YDAoLskQQ5MOAgvHUQCcLaa0P60JZGaCMFbL3N9v4H0.woff2) format('woff2');
        unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
      }
      /* latin */
      @font-face {
        font-family: 'Yanone Kaffeesatz';
        font-style: normal;
        font-weight: 400;
        src: local('Yanone Kaffeesatz Regular'), local('YanoneKaffeesatz-Regular'), url(../fonts/YDAoLskQQ5MOAgvHUQCcLWjF_m7mVnhXExjNED3rUtY.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }

      /* latin */
      @font-face {
        font-family: 'Droid Serif';
        font-style: normal;
        font-weight: 400;
        src: local('Droid Serif'), local('DroidSerif'), url(../fonts/0AKsP294HTD-nvJgucYTaIgp9Q8gbYrhqGlRav_IXfk.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
      /* latin */
      @font-face {
        font-family: 'Droid Serif';
        font-style: normal;
        font-weight: 700;
        src: local('Droid Serif Bold'), local('DroidSerif-Bold'), url(../fonts/QQt14e8dY39u-eYBZmppwf79_ZuUxCigM2DespTnFaw.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
      /* latin */
      @font-face {
        font-family: 'Droid Serif';
        font-style: italic;
        font-weight: 400;
        src: local('Droid Serif Italic'), local('DroidSerif-Italic'), url(../fonts/cj2hUnSRBhwmSPr9kS589weOulFbQKHxPa89BaxZzA0.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 700;
        src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url(../fonts/ceqTZGKHipo8pJj4molytv79_ZuUxCigM2DespTnFaw.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }
      @font-face {
        font-family: 'Ubuntu Mono';
        font-style: normal;
        font-weight: 400;
        src: local('Ubuntu Mono'), local('UbuntuMono-Regular'), url(../fonts/ViZhet7Ak-LRXZMXzuAfkYgp9Q8gbYrhqGlRav_IXfk.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
      }

      body {
        font-family: Futura, 'Yanone Kaffeesatz';
      }
      li {
        font-size: 30px;
        padding-top: 20px;
      }
      .remark-code {
        font-size: 30px;
      }
      h1, h2, h3 {
        font-weight: normal;
      }
      .inverse {
        background: #4795c6;
        color: white;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
      }
      .relative h1 {
        position: relative !important;
      }
      .question {
        background: #76b242;
        color: white;
      }
      .rule {
        background: #ee2a24;
        color: white;
      }
      .error {
        color: #ee2a24;
        font-size: 30px;
      }
      .image {
        padding: 0px;
        color: white;
        background-color: black;

        position: relative;
      }
      .image img {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        float: left;
      }
      .image h1, .image h2 {
        position: absolute;
        bottom: 0;
        text-align: center;
        left: 20px;
      }
      .image-white {
        color: black;
        background-color: white;
      }
      .image-last h1 {
        right: 0;
        bottom: 100px;
      }
      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono';
      }
      .remark-slide-content {
        padding: 10px 10px 10px 30px;
      }
      .hljs-default .hljs {
        background-color: transparent;
        padding: 0px !important;
      }
      .top h1 {
        top: 0px;
      }
      .toc {
         color: #777;
         margin-top: 135px;
      }
      .toc-selected {
         color: #000;
      }
      .code-small .remark-code {
        font-size: 20px;
      }
      .remark-container {
        height: 100%;
        width: 100%;
      }
      .remark-slide-number {
        display: none;
      }
      .red span {
        color: red;
      }
    </style>
  </head>
  <body>

    <textarea id="source">
name: image
layout: true
class: center, middle, image

---
name: image-white
layout: true
class: center, middle, image, image-white

---
name: image-last
layout: true
class: center, middle, image, image-last

---
name: code-small
layout: true
class: code-small

---
name: question
layout: true
class: center, middle, question

---
name: rule
layout: true
class: center, middle, rule

---
name: boom
layout: true
class: boom

---
name: inverse
layout: true
class: center, middle, inverse

---

class: center, middle
template: image


# Part 2















---

template: inverse
## Lists

---

layout: false

## Lists

```haskell
list :: [Int]
list = [1, 2, 3]
```

---

layout: false

## Lists

```haskell
list :: [Int]
list = [1, 2, 3]
```

### Javascript

```js
function list() {
  return [1, 2, 3];
}
```

---

template: question

## Plus one to every element?

---

## Map

```haskell
plusOne :: Int -> Int
plusOne x =
  x + 1
```

---

## Map

```haskell
plusOne :: Int -> Int
plusOne x =
  x + 1

plusOneList :: [Int] -> [Int]
plusOneList list =
  ??? plusOne list
```

---

## Map

```haskell
plusOne :: Int -> Int
plusOne x =
  x + 1

plusOneList :: [Int] -> [Int]
plusOneList list =
  map plusOne list
```

---

## Map

```haskell
plusOne :: Int -> Int
plusOne x =
  x + 1

plusOneList :: [Int] -> [Int]
plusOneList list =
  map plusOne list
```

```haskell
> plusOneList [1, 2, 3]
[2,3,4]
```

---

## Map

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-title">plusOne</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span></div><div class="remark-code-line"><span class="hljs-title">plusOne</span> x =</div><div class="remark-code-line">  x + <span class="hljs-number">1</span></div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-title">plusOneList</span> :: [<span class="hljs-type">Int</span>] -&gt; [<span class="hljs-type">Int</span>]</div><div class="remark-code-line"><span class="hljs-title">plusOneList</span> list =</div><div class="remark-code-line">  map plusOne list</div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-title">map</span> :: (<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>) -&gt; [<span class="hljs-type">Int</span>] -&gt; [<span class="hljs-type">Int</span>]</div>
</code></pre>

---

## Map

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-title">plusOne</span> :: <span style="color: red;">Int -&gt; Int</span></div><div class="remark-code-line"><span class="hljs-title">plusOne</span> x =</div><div class="remark-code-line">  x + <span class="hljs-number">1</span></div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-title">plusOneList</span> :: [<span class="hljs-type">Int</span>] -&gt; [<span class="hljs-type">Int</span>]</div><div class="remark-code-line"><span class="hljs-title">plusOneList</span> list =</div><div class="remark-code-line">  map plusOne list</div><div class="remark-code-line"></div><div class="remark-code-line"><span class="hljs-title">map</span> :: (<span style="color: red;">Int -&gt; Int</span>) -&gt; [<span class="hljs-type">Int</span>] -&gt; [<span class="hljs-type">Int</span>]</div>
</code></pre>

---

## Not the same

```haskell
plusOne :: Int -> Int
plusOne x =
  x + 1

plusOneList :: [Int] -> [Int]
plusOneList list =
  map plusOne list

map :: (Int -> Int) -> [Int] -> [Int]

mapNot :: Int -> Int -> [Int] -> [Int]
```
---

## Comparison

```haskell
plusOne :: Int -> Int
plusOne x =
  x + 1

plusOneList :: [Int] -> [Int]
plusOneList list =
  map plusOne list
```

### Javascript

```js
function plusOne(x) {
  return x + 1;
}
function plusOneList(list) {
  return list.map(plusOne);
}
```

---

## Local functions

```haskell
plusOne :: Int -> Int
plusOne x =
  x + 1

plusOneList :: [Int] -> [Int]
plusOneList list =
  map plusOne list
```

### Javascript

```js
function plusOneList(list) {
  function plusOne(x) {
    return x + 1;
  }
  return list.map(plusOne);
}
```

---

## Let binding

```haskell




plusOneList :: [Int] -> [Int]
plusOneList list =
  let plusOne x = x + 1
  in map plusOne list
```

### Javascript

```js
function plusOneList(list) {
  function plusOne(x) {
    return x + 1;
  }
  return list.map(plusOne);
}
```

---

template: question

## Uppercase a list of characters

---

## Map

```haskell
import Data.Char

toUpper :: Char -> Char
```

---

## Map

```haskell
import Data.Char

toUpper :: Char -> Char

toUpperList :: [Char] -> [Char]
toUpperList list =
  map toUpper list
```

---

## Map

```haskell
import Data.Char

toUpper :: Char -> Char

toUpperList :: [Char] -> [Char]
toUpperList list =
  map toUpper list
```

```haskell
> toUpperList ['a', 'b', 'c']
['A','B','C']
```

---

## Lies

```haskell
import Data.Char

toUpper :: Char -> Char

toUpperList :: [Char] -> [Char]
toUpperList list =
  map toUpper list
```

```haskell
> toUpperList ['a', 'b', 'c']
"ABC"
```

---

## String = [Char]

```haskell
import Data.Char

toUpper :: Char -> Char

toUpperList :: [Char] -> [Char]
toUpperList list =
  map toUpper list
```

```haskell
> toUpperList "abc"
"ABC"
```

---

## Map

```haskell
import Data.Char

toUpper :: Char -> Char

toUpperList :: [Char] -> [Char]
toUpperList list =
  map toUpper list

map :: (Char -> Char) -> [Char] -> [Char] 
```

---

## What does haskell think?

```
> :t map
```

---

## What does haskell think?

```
map :: (a -> b) -> [a] -> [b]
```

---

## Parametric function

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</div>
</code></pre>

### Java

<pre><code class="java hljs remark-code"><div class="remark-code-line"><span class="hljs-keyword">interface</span> List<span>&lt;</span>A&gt; {</div><div class="remark-code-line">  <span class="hljs-keyword">public</span> <span>&lt;</span>B&gt; List<span>&lt;</span>B&gt; map(Function<span>&lt;</span>A, B&gt; f) {</div><div class="remark-code-line">    ...</div><div class="remark-code-line">  }</div><div class="remark-code-line">}</div>
</code></pre>

---

## Parametric function

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-title">map</span> :: (a -&gt; b) -&gt; [<span style="color: red;">a</span>] -&gt; [b]</div>
</code></pre>

### Java

<pre><code class="java hljs remark-code"><div class="remark-code-line"><span class="hljs-keyword">interface</span> List<span>&lt;</span><span style="color: red;">A</span>&gt; {</div><div class="remark-code-line">  <span class="hljs-keyword">public</span> <span>&lt;</span>B&gt; List<span>&lt;</span>B&gt; map(Function<span>&lt;</span>A, B&gt; f) {</div><div class="remark-code-line">    ...</div><div class="remark-code-line">  }</div><div class="remark-code-line">}</div>
</code></pre>

---

## Parametric function

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [<span style="color: red;">b</span>]</div>
</code></pre>

### Java

<pre><code class="java hljs remark-code"><div class="remark-code-line"><span class="hljs-keyword">interface</span> List<span>&lt;</span>A&gt; {</div><div class="remark-code-line">  <span class="hljs-keyword">public</span> <span>&lt;</span>B&gt; List<span>&lt;</span><span style="color: red;">B</span>&gt; map(Function<span>&lt;</span>A, B&gt; f) {</div><div class="remark-code-line">    ...</div><div class="remark-code-line">  }</div><div class="remark-code-line">}</div>
</code></pre>

---

## Parametric function

<pre><code class="haskell hljs remark-code"><div class="remark-code-line"><span class="hljs-title">map</span> :: (<span style="color: red;">a</span> -&gt; <span style="color: blue;">b</span>) -&gt; [a] -&gt; [b]</div>
</code></pre>

### Java

<pre><code class="java hljs remark-code"><div class="remark-code-line"><span class="hljs-keyword">interface</span> List<span>&lt;</span>A&gt; {</div><div class="remark-code-line">  <span class="hljs-keyword">public</span> <span>&lt;</span>B&gt; List<span>&lt;</span>B&gt; map(Function<span>&lt;</span><span style="color: red;">A</span>, <span style="color: blue;">B</span>&gt; f) {</div><div class="remark-code-line">    ...</div><div class="remark-code-line">  }</div><div class="remark-code-line">}</div>
</code></pre>

---

## Parametric function

```haskell
map :: (a -> b) -> [a] -> [b]
```

- Lowercase means type variable
  - Rember that uppercase is a "type"
- Don't need to "introduce" it











---

template: question

## Data

---

## Remember this?

```haskell
data MaybeFruit = JustFruit Fruit | NothingFruit

fruitFromString :: String -> MaybeFruit
```

---

## Copy and paste

```haskell
data MaybeVege = JustVege Vege | NothingVege

vegeFromString :: String -> MaybeVege
```

---

## Copy and paste

```haskell
data Maybe??? = Just??? ??? | Nothing???

???FromString :: String -> Maybe???
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing
```

```haskell
> :t Just
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing
```

```haskell
> :t Just
a -> Maybe a
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing
```

```haskell
> :t Just Apple
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing
```

```haskell
> :t Just Apple
Maybe Fruit
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing
```

```haskell
> :t Just "hello"
Maybe String
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing

fruitFromString :: String -> Maybe Fruit
```

---

## Maybe

```haskell
data Maybe a = Just a | Nothing

fruitFromString :: String -> Maybe Fruit
fruitFromString string = case string of
  "apple" -> Just Apple
  "banana" -> Just Banana
  "tomato" -> Just Tomato
  _ -> Nothing
```












    </textarea>
    <link rel="stylesheet" href="../js/styles/idea.css">
    <script src="../js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
