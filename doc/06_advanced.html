<!DOCTYPE html>
<html>
  <head>
    <title>Haskell in Haste - Advanced</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="../js/styles.css" />
  </head>
  <body>

    <textarea id="source">
name: image
layout: true
class: center, middle, image

---
name: title
layout: true
class: center, middle, image, image-white, title

---
name: image-white
layout: true
class: center, middle, image, image-white

---
name: image-last
layout: true
class: center, middle, image, image-last

---
name: code-small
layout: true
class: code-small

---
name: question
layout: true
class: center, middle, question

---
name: rule
layout: true
class: center, middle, rule

---
name: boom
layout: true
class: boom

---
name: inverse
layout: true
class: center, middle, inverse

---

class: center, middle
template: title
layout: false

# Advanced











---
template: inverse

## Lambda

---

layout: false
## Lambda

```haskell
add :: Int -> Int -> Int
add a b = a + b
```

---

## Lambda

```haskell
add :: Int -> Int -> Int
add a b = a + b
```

### Javascript

```javascript
function add(a, b) {
  return a + b;
}
```

---

## Lambda

```haskell

add = \a b -> a + b
```

---

## Lambda

```haskell

add = \a b -> a + b

> :t add
Int -> Int -> Int
```

---

## Lambda

```haskell
add :: Int -> Int -> Int
add = \a b -> a + b
```

---

## Lambda

```haskell
add :: Int -> Int -> Int
add = \a b -> a + b
```

### Javascript

```javascript
val add = function(a, b) {
  return a + b;
}
```












---

template: inverse

## Higher Order Functions

---

## Higher Order Function

```haskell


let
    add3 x = x + 3
in map add3 [1, 2, 3]
```

---

## Higher Order Function

```haskell


let
    add3 x = x + 3
in map add3 [1, 2, 3]

> [4,5,6]
```

---

## Higher Order Function

```haskell


let
    add3 x = x + 3
in map add3 [1, 2, 3]
```

### Javascript

```js
var add3 = function(x) {
  return x + 3;
};
[1, 2, 3].map(add3);
```

---

## Higher Order Function

```haskell
map :: (Int -> Int) -> [Int] -> [Int]

let
    add3 x = x + 3 
in map add3 [1, 2, 3]
```

---

## Higher Order Function

```haskell
map :: (Int -> Int) -> [Int] -> [Int]

let add3 :: Int -> Int
    add3 x = x + 3 
in map add3 [1, 2, 3]
```












---

template: inverse
## Do notation

---

## Hello world

```haskell

main =
  putStrLn "Hello world"
```

---

## Hello world

```haskell

main =
  putStrLn "Hello world"
```

```
:t main
> main :: IO ()
```

---

## Hello world

```haskell
main :: IO ()
main =
  putStrLn "Hello world"
```

---

## What about?

```haskell
main :: IO ()
main =
  putStrLn "Hello world"
  putStrLn "Almost there"
```

---

## What about?

```haskell
main :: IO ()
main =
  putStrLn "Hello world"
  putStrLn "Almost there"
```

<pre class="error" style="font-size: 20px;">
main.hs:12:3:
    Couldn't match expected type ‘(String -> IO ()) -> String -> IO ()’
                with actual type ‘IO ()’
    The function ‘putStrLn’ is applied to three arguments,
    but its type ‘String -> IO ()’ has only one
</pre>

---

## What that means

```haskell
main :: IO ()
main =
  putStrLn "Hello world" putStrLn "Almost there"
```

---

## What that means

```haskell
main :: IO ()
main =
  putStrLn "Hello world" putStrLn "Almost there"
```

### Javascript

```js
putStrLn("Hello world", putStrLn, "Almost there");
```

---

## What can we *do*?

```haskell
main :: IO ()
main =
  putStrLn "Hello world"
  putStrLn "Almost there"
```

---

## What can we *do*?

```haskell
main :: IO ()
main = do
  putStrLn "Hello world"
  putStrLn "Almost there"
```

---

## What can we *do*?

```haskell
main :: IO ()
main = do
  putStrLn "Hello world"
  putStrLn "Almost there"
```

```
> main
"Hello world"
"Almost there"
```





    </textarea>
    <link rel="stylesheet" href="../js/styles/idea.css">
    <script src="../js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
